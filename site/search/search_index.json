{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TP TEST LOGICIEL - GL4","text":"<p>Ce cours comporte 4  s\u00e9ances de travaux pratiques:</p> <ul> <li>TP1: Apprendre les tests unitaires en JavaScript avec Vitest</li> <li>TP2: </li> <li>TP3: </li> <li>TP4:</li> </ul>"},{"location":"tp1/","title":"Apprendre les tests unitaires en JavaScript avec Vitest","text":""},{"location":"tp1/#objectifs-du-tp","title":"Objectifs du TP","text":"<ol> <li>Comprendre l'importance des tests unitaires dans le d\u00e9veloppement logiciel.</li> <li>Apprendre \u00e0 \u00e9crire des tests unitaires en JavaScript.</li> <li>Ma\u00eetriser l'utilisation de Vitest pour l'ex\u00e9cution des tests unitaires.</li> </ol>"},{"location":"tp1/#duree-estimee","title":"Dur\u00e9e estim\u00e9e","text":"<p>3 heures</p>"},{"location":"tp1/#plan-du-tp","title":"Plan du TP","text":"<ol> <li> <p>Introduction aux tests unitaires</p> <ul> <li>D\u00e9finition des tests unitaires.</li> <li>Avantages des tests unitaires dans le d\u00e9veloppement logiciel.</li> </ul> </li> <li> <p>Pr\u00e9sentation de Vitest</p> <ul> <li>Pr\u00e9sentation de Vitest : Qu'est-ce que c'est et pourquoi l'utiliser ?</li> <li>Installation de Vitest dans un projet JavaScript.</li> </ul> </li> <li> <p>\u00c9criture de tests unitaires avec Vitest</p> <ul> <li>Structure des tests avec Vitest.</li> <li>\u00c9criture de tests simples pour les fonctions JavaScript.</li> <li>Utilisation des assertions pour v\u00e9rifier les r\u00e9sultats attendus.</li> <li>Gestion des fonctions asynchrones</li> <li>Techniques avanc\u00e9es d'\u00e9criture de tests avec Vitest</li> </ul> </li> <li> <p>Techniques avanc\u00e9es d'\u00e9criture de tests avec Vitest</p> <ul> <li>Utilisation des mocks </li> </ul> </li> </ol>"},{"location":"tp1/#introduction-aux-tests-unitaires","title":"Introduction aux tests unitaires","text":""},{"location":"tp1/#definition-des-tests-unitaires","title":"D\u00e9finition des tests unitaires","text":"<ul> <li>Les tests unitaires sont des proc\u00e9dures pour v\u00e9rifier si une unit\u00e9 de code (fonction, m\u00e9thode, classe) fonctionne correctement.</li> <li>Objectif principal : isoler et tester chaque composant de mani\u00e8re ind\u00e9pendante.</li> </ul>"},{"location":"tp1/#concepts-de-base-des-tests-unitaires","title":"Concepts de base des tests unitaires","text":"<ol> <li> <p>Compr\u00e9hension de l'unit\u00e9 de test</p> <ul> <li>Une unit\u00e9 de test est la plus petite partie testable d'une application.</li> <li>Elle devrait \u00eatre simple, isol\u00e9e et ind\u00e9pendante des autres parties du code.</li> </ul> </li> <li> <p>Principes fondamentaux des tests unitaires</p> <ul> <li>F.I.R.S.T. : Les tests unitaires doivent \u00eatre Fast, Isolated, Repeatable, Self-validating et Timely.</li> <li>Test Driven Development (TDD) : Une approche de d\u00e9veloppement o\u00f9 les tests unitaires sont \u00e9crits avant le code de production.</li> </ul> </li> <li> <p>Diff\u00e9rence entre les tests unitaires et les autres types de tests</p> <ul> <li>Tests d'int\u00e9gration : Testent les interactions entre les diff\u00e9rentes parties d'une application.</li> <li>Tests syst\u00e8me : Testent l'application dans son ensemble pour s'assurer qu'elle fonctionne comme pr\u00e9vu.</li> </ul> </li> <li> <p>Outils couramment utilis\u00e9s pour les tests unitaires</p> <ul> <li>Frameworks de tests : Jest, Mocha, Jasmine, etc.</li> <li>Biblioth\u00e8ques d'assertions : Chai, Assert, etc.</li> <li>Outils de mocking : Sinon, Mockito, etc.</li> </ul> </li> </ol>"},{"location":"tp1/#avantages-des-tests-unitaires-dans-le-developpement-logiciel","title":"Avantages des tests unitaires dans le d\u00e9veloppement logiciel","text":"<ul> <li>R\u00e9duction des bugs : Les tests unitaires permettent de d\u00e9tecter et corriger les erreurs d\u00e8s leur apparition.</li> <li>Facilitation de la maintenance : En fournissant une r\u00e9troaction rapide sur les changements de code, les tests unitaires rendent la maintenance plus efficace.</li> <li>Am\u00e9lioration de la conception : Les tests unitaires encouragent une conception modulaire et une meilleure s\u00e9paration des pr\u00e9occupations.</li> <li>Acc\u00e9l\u00e9ration du d\u00e9veloppement : En automatisant les tests, les d\u00e9veloppeurs gagnent du temps et peuvent se concentrer sur de nouvelles fonctionnalit\u00e9s.</li> </ul>"},{"location":"tp1/#objectifs-des-tests-unitaires","title":"Objectifs des tests unitaires","text":"<ul> <li>Assurer la fonctionnalit\u00e9 attendue de chaque composant individuel.</li> <li>R\u00e9duire les risques lors des modifications ou des ajouts de fonctionnalit\u00e9s.</li> <li>Fournir une documentation vivante du comportement attendu du code.</li> </ul>"},{"location":"tp1/#presentation-de-vitest","title":"Pr\u00e9sentation de Vitest","text":"<ol> <li> <p>Introduction \u00e0 Vitest : qu'est-ce que c'est ?</p> <ul> <li>Vitest est un framework de tests unitaires pour JavaScript.</li> <li>Il offre une syntaxe simple et expressive pour \u00e9crire des tests unitaires.</li> </ul> </li> <li> <p>Raisons d'utiliser Vitest pour les tests unitaires</p> <ul> <li>Facilit\u00e9 d'utilisation : Vitest est facile \u00e0 apprendre et \u00e0 utiliser pour les d\u00e9veloppeurs JavaScript.</li> <li>Performance : Vitest offre des performances \u00e9lev\u00e9es pour l'ex\u00e9cution des tests unitaires.</li> </ul> </li> <li> <p>Caract\u00e9ristiques principales de Vitest</p> <ul> <li>Syntaxe intuitive : Les tests unitaires avec Vitest sont \u00e9crits de mani\u00e8re d\u00e9clarative et facile \u00e0 comprendre.</li> <li>Support des promesses : Vitest prend en charge les tests asynchrones avec des promesses.</li> <li>Comparaison avec Jest, Mocha, Jasmine, etc.</li> <li>Points forts et faiblesses de Vitest par rapport aux autres frameworks.</li> </ul> </li> <li> <p>Installation de Vitest dans un projet JavaScript</p> <p>a. Pr\u00e9requis pour installer Vitest</p> <ul> <li>Node.js install\u00e9 sur le syst\u00e8me</li> <li>Un projet JavaScript existant ou nouvellement cr\u00e9\u00e9</li> </ul> <p>b. Installation de Vitest via npm</p> <pre><code>npm install -D vitest\n</code></pre> <p>c. Configuration de Vitest dans un projet JavaScript</p> <p>Une fois que vous avez install\u00e9 Vitest dans votre projet JavaScript, vous devez le configurer correctement pour qu'il fonctionne efficacement. Voici les \u00e9tapes de configuration :</p> <ul> <li>Configuration initiale de Vitest dans le fichier de configuration du projet.</li> </ul> <p>Dans le fichier package.json ajouter la configuration suivante:             <pre><code>    {\n\"scripts\": {\n    \"test\": \"vitest\"\n}\n}\n</code></pre></p> <ul> <li>Sp\u00e9cification des r\u00e9pertoires de tests et de leur structure. Il est important de sp\u00e9cifier les r\u00e9pertoires o\u00f9 se trouvent vos tests ainsi que leur structure. Vitest suit g\u00e9n\u00e9ralement une convention de structuration des tests pour faciliter l'organisation et l'ex\u00e9cution des tests. Assurez-vous de respecter cette convention pour que Vitest puisse d\u00e9couvrir et ex\u00e9cuter vos tests correctement.</li> </ul> <p>Par exemple, vous pourriez organiser vos tests dans un r\u00e9pertoire tests \u00e0 la racine de votre projet, avec des sous-r\u00e9pertoires pour chaque module ou composant, et des fichiers de test portant le m\u00eame nom que les fichiers qu'ils testent.</p> <pre><code>    project/\n\u251c\u2500\u2500 src/\n\u2502 \u251c\u2500\u2500 module1.js\n\u2502 \u2514\u2500\u2500 module2.js\n\u2514\u2500\u2500 tests/\n\u251c\u2500\u2500 module1.test.js\n\u2514\u2500\u2500 module2.test.js\n</code></pre> </li> </ol>"},{"location":"tp1/#ecriture-de-tests-unitaires-en-javascript-avec-vitest","title":"\u00c9criture de tests unitaires en JavaScript avec Vitest","text":"<p>Dans cette partie, nous allons plonger dans l'\u00e9criture de tests unitaires en JavaScript en utilisant Vitest. Nous allons commencer par comprendre la structure de base des tests avec Vitest, puis nous allons \u00e9crire des tests simples pour des fonctions JavaScript, en utilisant des assertions pour v\u00e9rifier les r\u00e9sultats attendus.</p>"},{"location":"tp1/#structure-des-tests-avec-vitest","title":"Structure des tests avec Vitest","text":"<p>Vitest propose une structure simple et claire pour l'\u00e9criture des tests unitaires. Voici un exemple de structure de test avec Vitest :</p> <pre><code>import { test } from 'vitest';\n\ntest('Nom du test', () =&gt; {\n  // Corps du test\n});\n</code></pre> <p>Dans cet exemple, nous utilisons la fonction test fournie par Vitest pour d\u00e9finir un nouveau test. \u00c0 l'int\u00e9rieur de la fonction test, nous sp\u00e9cifions le nom du test et le corps du test, o\u00f9 nous effectuons nos v\u00e9rifications.</p>"},{"location":"tp1/#ecriture-de-tests-simples","title":"\u00c9criture de tests simples","text":"<p>Voyons maintenant comment \u00e9crire des tests simples pour des fonctions JavaScript. Supposons que nous ayons une fonction add qui additionne deux nombres. Voici comment nous pourrions \u00e9crire un test pour cette fonction :</p> <pre><code>import { test } from 'vitest';\nimport { add } from './math'; // Supposons que 'add' est une fonction export\u00e9e depuis un fichier 'math.js'\n\ntest('Test de la fonction add', () =&gt; {\n  const result = add(2, 3);\n  expect(result).toBe(5);\n});\n</code></pre> <p>Activit\u00e9-1</p> <ol> <li> <p>Cr\u00e9er un nouveau projet TP1 avec votre IDE pr\u00e9f\u00e9r\u00e9</p> </li> <li> <p>Cr\u00e9er un fichier <code>math.js</code> dans lequel ajouter une fonction <code>add</code> qui calcule la somme de deux entiers.</p> </li> <li> <p>Cr\u00e9er un dossier <code>test</code>, sous lequel cr\u00e9er un fichier que vous nommez <code>math.test.js</code>.</p> </li> <li> <p>Suivre les \u00e9tapes mentionn\u00e9es dans la section 2 pour installer Vitest.</p> </li> <li> <p>Modifier le fichier package.json pour ajouter la section \"scripts\", Ajoutez la section \"scripts\" dans votre fichier package.json comme suit :</p> <pre><code>\"scripts\": {\n\"dev\": \"vite\",\n\"build\": \"vite build\",\n\"preview\": \"vite preview\",\n\"test\": \"vitest\"}\n</code></pre> </li> <li> <p>Copier le code ci-dessus pour tester la fonction <code>add</code>.</p> </li> <li> <p>Ex\u00e9cuter le test avec la commande <code>npm run test</code></p> </li> </ol>"},{"location":"tp1/#utilisation-des-assertions-pour-verifier-les-resultats-attendus","title":"Utilisation des assertions pour v\u00e9rifier les r\u00e9sultats attendus.","text":"<p>Vitest utilise des assertions pour v\u00e9rifier si le comportement attendu est respect\u00e9 par le code test\u00e9. Voici quelques-unes des assertions les plus couramment utilis\u00e9es :</p> <ul> <li><code>expect(value).toBe(expected)</code>: V\u00e9rifie si <code>value</code> est strictement \u00e9gal \u00e0 <code>expected</code>.</li> <li><code>expect(value).toEqual(expected)</code>: V\u00e9rifie si <code>value</code> est \u00e9gal \u00e0 <code>expected</code> en effectuant une comparaison en profondeur pour les objets et les tableaux.</li> <li><code>expect(value).toBeTruthy()</code>: V\u00e9rifie si <code>value</code> est \u00e9valu\u00e9 \u00e0 <code>true</code>.</li> <li><code>expect(value).toBeFalsy()</code>: V\u00e9rifie si <code>value</code> est \u00e9valu\u00e9 \u00e0 <code>false</code>.</li> <li><code>expect(value).toContain(expected)</code>: V\u00e9rifie si <code>value</code> contient <code>expected</code> (pour les cha\u00eenes de caract\u00e8res et les tableaux).</li> </ul> <p>Note</p> <p>Visitez ce lien pour plus de d\u00e9tails sur les assertions.</p>"},{"location":"tp1/#exercice-1","title":"Exercice 1","text":""},{"location":"tp1/#objectif","title":"Objectif","text":"<p>\u00c9crire des tests unitaires pour une fonction de manipulation de cha\u00eenes.</p>"},{"location":"tp1/#description","title":"Description","text":"<p>La t\u00e2che consiste \u00e0 \u00e9crire des tests unitaires pour une fonction de manipulation de cha\u00eenes impl\u00e9ment\u00e9e en JavaScript. La fonction prendra une cha\u00eene de caract\u00e8res en entr\u00e9e et effectuera une op\u00e9ration de transformation sur cette cha\u00eene.</p> <p>Activit\u00e9</p> <ol> <li>Impl\u00e9mentez la fonction transformer qui transforme une chaine de caract\u00e8res en Majuscule.</li> <li> <p>\u00c9crivez au moins trois cas de tests unitaires pour la fonction transformer. Assurez-vous de tester les cas suivants :</p> <ul> <li>Une cha\u00eene vide.</li> <li>Une cha\u00eene avec des caract\u00e8res en minuscules.</li> <li>Une cha\u00eene avec des caract\u00e8res sp\u00e9ciaux.</li> </ul> </li> <li> <p>Utilisez diff\u00e9rentes assertions pour v\u00e9rifier si la fonction transformer renvoie la cha\u00eene transform\u00e9e correctement.</p> </li> <li>Assurez-vous que vos tests couvrent tous les cas de figure possibles pour garantir que la fonction de manipulation de cha\u00eenes fonctionne correctement dans diverses situations</li> </ol>"},{"location":"tp1/#exercice-2","title":"Exercice 2","text":""},{"location":"tp1/#objectif_1","title":"Objectif","text":"<p>\u00c9crire des tests unitaires pour une fonction de tri.</p>"},{"location":"tp1/#description_1","title":"Description","text":"<p>La t\u00e2che consiste \u00e0 \u00e9crire des tests unitaires pour une fonction de tri impl\u00e9ment\u00e9e en JavaScript. La fonction de tri prendra un tableau de nombres en entr\u00e9e et triera ces nombres par ordre croissant.</p> <p>Activit\u00e9</p> <ol> <li>Impl\u00e9mentez la fonction trier en JS.</li> <li>Ecrivez au moins 3 cas de test.</li> <li>Utilisez des assertions pour v\u00e9rifier si la fonction trier renvoie le tableau tri\u00e9 correctement.</li> <li>Assurez-vous que vos tests couvrent tous les cas de figure possibles, y compris les tableaux d\u00e9j\u00e0 tri\u00e9s, les tableaux invers\u00e9s, etc.</li> <li>Assurez-vous de tester \u00e9galement les cas limites et les situations d'erreur potentielles, comme les tableaux avec des \u00e9l\u00e9ments non num\u00e9riques.</li> </ol>"},{"location":"tp1/#exercice-3","title":"Exercice 3","text":""},{"location":"tp1/#objectif_2","title":"Objectif","text":"<p>Test au valeurs limites : Boundary testing.</p>"},{"location":"tp1/#description_2","title":"Description","text":"<p>La fonction isPriceInRange(price, min, max) v\u00e9rifie si un prix donn\u00e9 se situe dans une plage donn\u00e9e.</p> <pre><code>export function isPriceInRange(price, min, max) {\n  return price &gt;= min &amp;&amp; price &lt;= max;\n}\n</code></pre> <p>Activit\u00e9</p> <p>\u00c9crivez des cas de test pour cette fonction en couvrant les limites de la plage ainsi que les cas o\u00f9 le prix est en dehors de la plage.</p>"},{"location":"tp1/#gestion-des-fonctions-asynchrones","title":"Gestion des fonctions asynchrones","text":"<p>Les fonctions asynchrones peuvent retourner des promesses ou utiliser des rappels (callbacks) pour indiquer la fin de leur ex\u00e9cution. Lorsque vous testez de telles fonctions, vous devez vous assurer que vos tests attendent la fin de l'ex\u00e9cution de ces fonctions avant de v\u00e9rifier les r\u00e9sultats. Vitest facilite cette attente en vous permettant d'utiliser les mots-cl\u00e9s await ou done pour g\u00e9rer l'asynchronisme dans vos tests.</p>"},{"location":"tp1/#utilisation-dawait","title":"Utilisation d'await","text":"<p>Lorsque vous testez des fonctions asynchrones avec Vitest, vous pouvez utiliser le mot-cl\u00e9 await pour attendre la r\u00e9solution ou le rejet des promesses retourn\u00e9es par ces fonctions. Cela vous permet d'ex\u00e9cuter des assertions une fois que la promesse est r\u00e9solue ou rejet\u00e9e, garantissant ainsi que votre test est ex\u00e9cut\u00e9 dans le bon ordre et que les r\u00e9sultats attendus sont correctement v\u00e9rifi\u00e9s.</p>"},{"location":"tp1/#gestion-des-erreurs","title":"Gestion des erreurs","text":"<p>Les fonctions asynchrones peuvent g\u00e9n\u00e9rer des erreurs pendant leur ex\u00e9cution, et il est important de les g\u00e9rer correctement dans vos tests. Vitest vous permet d'utiliser les blocs try/catch pour capturer et traiter les erreurs potentielles g\u00e9n\u00e9r\u00e9es par les fonctions asynchrones lors de l'ex\u00e9cution de vos tests.</p>"},{"location":"tp1/#attente-explicite","title":"Attente explicite","text":"<p>Dans certains cas, vous devrez peut-\u00eatre attendre un certain d\u00e9lai avant de v\u00e9rifier les r\u00e9sultats d'une fonction asynchrone. Vitest fournit des m\u00e9thodes pour g\u00e9rer cette attente explicite, comme setTimeout ou setImmediate, pour s'assurer que votre test donne suffisamment de temps \u00e0 la fonction asynchrone pour terminer son ex\u00e9cution avant de proc\u00e9der \u00e0 la v\u00e9rification.</p>"},{"location":"tp1/#exemple","title":"Exemple","text":"<p>Supposons que nous avons une fonction asynchrone fetchData() qui effectue une requ\u00eate HTTP pour r\u00e9cup\u00e9rer des donn\u00e9es d'un serveur distant. Nous voulons tester cette fonction pour nous assurer qu'elle renvoie les donn\u00e9es attendues.</p> <pre><code>export async function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  if (!response.ok) {\n    throw new Error('Failed to fetch data');\n  }\n  const data = await response.json();\n  return data;\n}\n</code></pre> <p>Voici comment nous pouvons \u00e9crire un test pour cette fonction avec Vitest :</p> <p><pre><code>import { fetchData } from './fetchData'; // Import de la fonction \u00e0 tester\n\ndescribe('fetchData()', () =&gt; {\n  it('should fetch data from the server', async () =&gt; {\n    try {\n      const data = await fetchData(); // Appel de la fonction asynchrone\n      // V\u00e9rification des r\u00e9sultats attendus\n      expect(data).toBeDefined(); // On s'assure que les donn\u00e9es ont \u00e9t\u00e9 renvoy\u00e9es\n      expect(Array.isArray(data)).toBe(true); // On v\u00e9rifie que les donn\u00e9es renvoy\u00e9es sont un tableau\n      // Ajoutez d'autres assertions selon les donn\u00e9es attendues\n    } catch (error) {\n      // Si une erreur se produit pendant l'ex\u00e9cution de la fonction asynchrone\n      // On signale le test comme \u00e9chou\u00e9\n      fail('Should not throw any error');\n    }\n  });\n});\n</code></pre> Dans cet exemple :</p> <p>Nous utilisons async dans la fonction de test pour indiquer que le test est asynchrone et qu'il utilise await pour attendre la r\u00e9solution de la promesse retourn\u00e9e par fetchData(). Nous appelons la fonction fetchData() \u00e0 l'int\u00e9rieur du bloc try/catch pour capturer toute erreur potentielle qui pourrait survenir lors de son ex\u00e9cution. Dans le bloc try, nous effectuons des assertions sur les donn\u00e9es renvoy\u00e9es par la fonction fetchData() pour nous assurer qu'elles correspondent \u00e0 ce que nous attendons. Si une erreur survient pendant l'ex\u00e9cution de la fonction asynchrone (par exemple, une erreur de r\u00e9seau ou une erreur de syntaxe), elle sera captur\u00e9e dans le bloc catch et le test sera signal\u00e9 comme un \u00e9chec en utilisant fail().</p>"},{"location":"tp1/#exercice","title":"Exercice","text":""},{"location":"tp1/#objectif_3","title":"Objectif","text":"<p>Impl\u00e9menter un test pour une fonction asynchrone qui r\u00e9cup\u00e8re des donn\u00e9es d'une API.</p>"},{"location":"tp1/#description_3","title":"Description","text":"<p>Nous avons une fonction asynchrone appel\u00e9e fetchRandomUser() qui r\u00e9cup\u00e8re les donn\u00e9es d'un utilisateur al\u00e9atoire \u00e0 partir de l'API \"Random User Generator\". L'objectif de l'exercice est d'\u00e9crire un test pour cette fonction pour v\u00e9rifier si elle renvoie les donn\u00e9es attendues de mani\u00e8re asynchrone. <pre><code>export async function fetchRandomUser() {\n  const response = await fetch('https://randomuser.me/api/');\n  if (!response.ok) {\n    throw new Error('Failed to fetch random user');\n  }\n  const data = await response.json();\n  return data.results[0]; // Renvoie les informations sur le premier utilisateur dans la liste\n}\n</code></pre></p> <p>Activit\u00e9</p> <p>1.Comprendre la fonction \u00e0 tester :</p> <p>La fonction fetchRandomUser() utilise l'API \"Random User Generator\" pour r\u00e9cup\u00e9rer les donn\u00e9es d'un utilisateur al\u00e9atoire. Elle renvoie un objet JSON contenant des informations sur cet utilisateur.</p> <p>2.\u00c9crire le test :</p> <p>Utilisez Vitest pour \u00e9crire un test pour la fonction fetchRandomUser(). Assurez-vous d'attendre de mani\u00e8re asynchrone la r\u00e9solution de la promesse retourn\u00e9e par la fonction. V\u00e9rifiez que les donn\u00e9es renvoy\u00e9es sont bien un objet JSON contenant les informations sur l'utilisateur.</p>"},{"location":"tp1/#couverture-de-code","title":"Couverture de code","text":"<p>Pour la couverture de code, c\u2019est-\u00e0-dire la v\u00e9rification du taux de code couvert par les tests unitaires \u2013 un indicateur de qualit\u00e9 de logiciel de plus en plus pr\u00e9sent dans les projets \u2013 il suffit d\u2019ajouter l\u2019option --coverage \u00e0 l\u2019appel du test, par exemple dans votre fichier package.json :</p> <pre><code>    \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\",\n    \"test:coverage\": \"vitest --coverage\"}\n</code></pre> <p>Ensuite, vous pouvez lancer la couverture de code avec : npm run test:coverage</p> <p></p>"},{"location":"tp1/#travail-a-rendre","title":"Travail \u00e0 rendre","text":"<p>Exercice</p> <p>Choisir un projet, qu'il soit personnel ou open-source, puis cr\u00e9ez au moins trois tests unitaires pour ce projet. Ensuite, ex\u00e9cuter ces tests en incluant le calcul de la couverture de code.</p>"}]}